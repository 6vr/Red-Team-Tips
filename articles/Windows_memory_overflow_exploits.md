Windows Memory Overflow Exploits
======================

Stack-Based Overflows
------------------------

This picture is worth a thousand words. Note how EIP gets overriden.
![](data/stack_overflow_diagram.png)


Patterns to Isolate EIP Bytes
-------------------------------

`/usr/share/metasploit-framework/tools/pattern_create.rb 50000`
`/usr/share/metasploit-framework/tools/pattern_offset.rb 2Ac3Ac4A 50000`

`!mona pc 50,000`
`!mona findmsp` - Locates EIP offset. Also provides other very useful information such as which registers contain portions of your buffer. However, it only finds the first instance of the bytes that overwrote EIP, whereas metasploit's tool finds all instances of those bytes in the pattern, only one of which actually overwrote EIP.


Where to Put Shellcode
-------------------------

From an example at http://www.securitysift.com/windows-exploit-development-part-2-intro-stack-overflow/.

Notice there are three registers that currently point to some location in our 50,000 byte buffer: EBX, ESP and EBP.

![](data/asx2mp3_immunity5.png)

We want to use our EIP overwrite to tell the application to redirect to one of these registers and execute the code it points to. Which register we choose depends on a couple of things:

- The amount of uninterrupted code at that location — sometimes our exploit code can be mangled or truncated as it’s written to memory by the application so we need to ensure that we have enough space to insert usable shellcode (usually at least 500 bytes) and that the code will not be modified in any way by the application.

- Our ability to redirect to one of those registers — in order to tell the application to redirect to a register that points to our shellcode, we need to overwrite EIP with an address to an existing instruction such as JMP or CALL .  Remember that EIP is overwritten with an address pointer to an instruction, not an actual instruction. In other words, we can’t overwrite EIP with opcode corresponding to jump ESP (\xff\xe4).  Instead, we need to overwrite it with a memory address that points to such an instruction. On top of that, we need to ensure that the address we use does not contain null bytes (\x00). Why? Because a null byte acts as a terminator, meaning that once the application hits the null byte, execution terminates and anything you put after the EIP overwrite (in this case our shellcode) will not be executed. There are some exceptions to the null byte rule but for this first example, just keep in mind we are trying to avoid addresses containing null bytes. If you’re confused by any this, don’t worry I’ll demonstrate.

Pushing and Popping Registers and Flags
--------------------------------------------

 The `PUSHAD` instruction always pushes all 8 general purpose registers onto the stack. A single `PUSHAD` instruction is equivilent to writing:

```
PUSH EAX
PUSH ECX
PUSH EDX
PUSH EBX
PUSH ESP
PUSH EBP
PUSH ESI
PUSH EDI
```

`POPAD` pops the values back off the stack in reverse order, thus restoring all the register values. Note that when the stack-stored ESP value gets POPed, it doesn't overwrite ESP but just gets discarded. The actual ESP actually maintains its normal behavior by incrementing down to higher memory addresses with each POP within the POPAD process.

`PUSHAD` and `POPAD` are useful for performing a easy save and restore of the general purpose registers without having to `PUSH` and `POP` every individual register in turn.

Similarly, `PUSHFD` and `POPFD` are used to save and restore the EFLAGS register. Although not really used that much in ordinary programs, the instructions are useful when (for example) a process context switch is performed (or anywhere else where the value of the flags register must be restored).

Question: How does the `PUSHFD` operation push a value such as 0x00000A46 to the stack?

It's just how the data is interpreted. The EFLAGS register is a set of 32 bits. If you divide the bits up into 8 groups of 4 (8*4=32), you can map each 4 bit chunk to a hexadecimal character (0..9,A-F). Likewise, you can convert the hexadecimal values back to a set of bits:

00000A46 = 0000(0) 0000(0) 0000(0) 0000(0) 0000(0) 1010(A) 0100(4) 0110(6)

These are the values of the bits that were stored in the EFLAGS register.



Example Code
=========

